# Dijkstra Algorithm(다익스트라 알고리즘)

#### 다이나믹 프로그래밍 기법(동적 프로그래밍)을 활용하였다.

#### 하지만 분류는 다이나믹 프로그래밍으로 분류될 수도 있고, 그리디 알고리즘으로 분류될 수도 있다.

* 여기서 다이나믹 프로그래밍은 큰 문제를 한 번에 해결하기 힘들 때 작은 문제들로 나눠서 푸는 프로그래밍 기법이다.
  * 다익스트라에서는 A에서 D로 가는 길이 A-B B-C C-D로 가는 경로가 최단 경로라면! A-B B-C로 가는 경로도 최단 경로가 되어야 한다. 그 값들을 매번 재계산 하지 않고, 저장 해뒀다가 재사용하기 때문에 다이나믹(동적) 프로그래밍이라고 할 수 있다.
* 여기서 그리디 알고리즘은 탐욕스러운, 욕심 많은 이라는 뜻이다. 말 그대로 선택의 순간마다 당장 눈 앞에 보이는 최적의 상황만을 쫓아서 최종적인 해답에 도달하는 알고리즘이다.



#### 알고리즘의 정의

* 다이나믹 프로그래밍을 활용한 대표적인 최단 경로 탐색 알고리즘.



#### 알고리즘의 목적

* 최단 경로 탐색



#### 우리 주위에서 볼 수 있는 대표적으로 쓰이는 곳

* 인공위성
* GPS
* 소프트웨어



#### 방법

* "특정한" 하나의 정점에서 다른 모든 정점으로 가는 최단 경로를 알려준다.



#### 알고리즘의 특징

* 하나의 최단 거리를 구할 때 그 이전까지 구했던 최단 거리 정보를 그대로 사용한다.
* 다익스트라는 그리디 알고리즘, 다이나믹 프로그래밍으로 분류된다.



#### 알고리즘의 단점

* 음의 간선을 포함할 수 없다. => 현실은 사이의 거리가 마이너스 값이 나올 수 없기에,  GPS 같은 곳에 사용하기 적합하다.



![image-20220109233637087](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20220109233637087.png)

<img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20220109234455342.png" alt="image-20220109234455342" style="zoom: 67%;" />

#### 각 정점으로 가는 노드 사이 간선을 이차원 배열 형태인 표로 만들어보겠습니다. A를 출발 노드로 설정합니다.

#### 각 정점(A, B, C, D, E, F, G)으로 향하는 비용 (0, 1, 1, 3, INF, INF, INF)을 기록합니다. 

#### 여기서 가장 비용이 적은 간선인 A-B, B-C를 선택했습니다. 하지만 노드의 순서로 B 노드를 선택해보겠습니다.

#### B 노드를 거쳐서 가는 경우를 모두 고려합니다. B-D로 A-D(3)보다 A-B-D(2)가 더 최소 비용으로, 배열을 갱신해줍니다.

![image-20220109235617940](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20220109235617940.png)

<img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20220109235712702.png" alt="image-20220109235712702" style="zoom: 80%;" />

#### 이런 식으로 반복해서 배열을 갱신해줍니다. 예를 들어 A에서 F로 바로 가는 길이 없다면 위에서 구해 저장했던 A-B-D 최소 비용값을 이용해 D에 연결된 노드인 F로 가는 최종 최소 비용을 구할 수 있는 것입니다.

![image-20220109103109263](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20220109103109263.png)



![image-20220112135607788](C:\Users\기능반\AppData\Roaming\Typora\typora-user-images\image-20220112135607788.png)

#### 구체적으로 1을 출발 노드로 설정하고, 각 정점으로 가는 최단 경로를 탐색한다고 생각해보자. 각 정점(2, 3, 4)으로 가는 비용 (6, 3, 5)을 계산하고, 가장 최소 비용이 드는 정점 3을 선택한다. 정점 3에서 다른 정점이랑 연결된 간선은 3-2가 있다. 이 비용은 1이며, 정점1-정점2로 가는 비용 6보다 저렴하다. 1-3-2(3+1) 그리고 2-4로 가는 비용1이 있다. 하지만 1-4로 가는 비용5와 1-3-2-1로 가는 비용(4 + 1)이 같기에 갱신되지 않는다. 이렇게 최단 거리를 구할 수 있다.

#### 이렇게 최소 비용이 나오며 갱신된다.

#### 한마디로, 현재까지 알고 있던 최단 경로를 계속해서 갱신 해주는 이것이 다익스트라 알고리즘이다.



#### 알고리즘의 과정

1. 출발 노드 설정
2. 출발 노드를 기준 정점으로 각 다른 정점인 노드의 최소 비용을 저장
3. 방문하지 않은 노드 중 가장 비용이 적은 노드 선택
4. 해당 노드를 거쳐서 목표가 되는 노드로 가는 경우를 고려해 최소 비용 갱신
5. 3~4번 반복



#### 알고리즘의 방법

* 첫번째 알고리즘인 선형 탐색은 차례대로 즉 순차적으로 배열을 순환하는 방식이다. 위 알고리즘은 최소 비용을 단순히 선형 탐색으로 찾도록 만들었다. 
* [시간 복잡도 = O(N^2)] 빠르게 작동시켜야하면 힙 구조를 활용하여 시간 복잡도 O(N*log N)을 만들 수 있다. 
* 위 알고리즘을 사용할 시, 정점의 갯수가 많은데 간선은 적을 때 치명적일 정도로 비효율일 수 있다.



* 두 번째 알고리즘인 인접 리스트는 인접 리스트의 방식을 활용하여 시간 복잡도를 O(N * log N)으로 구현한 것이다. 
* 이 알고리즘은 정점에 비해 간선의 갯수가 비정상적으로 적어도 선형 탐색과는 다르게 안정적으로 처리할 수 있다.